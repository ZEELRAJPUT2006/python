                     ****  Introduction to Python Theory: ***
 Q.1 Introduction to Python and its Features (simple, high-level, interpreted language).
  =======================================================================================
Ans: Python is a high-level, interpreted programming language developed by Guido van Rossum in 1991. It is one of the most popular programming languages today because of its simplicity, readability, and versatility. Python is widely used in web development, data science, artificial intelligence, automation, and many other fields.

-- Features of Python:
1. simple and easy to learn:
=  Python’s syntax is very close to English, making it beginner-friendly.
   Example: print("Hello, World!")

2. high-level language:
=  Programmers don’t need to worry about low-level details like memory management.
=  Makes development faster and easier.

3. interpreted language:
=  Code is executed line by line using an interpreter.
=  No need to compile before running.

4. Cross-Platform:
=  Python works on Windows, macOS, Linux, etc. without modification.

5. Object-Oriented:
=  Supports classes, objects, inheritance, and encapsulation.

6. Extensive Standard Library:
=  Comes with built-in modules (like math, datetime, os, etc.) to perform many tasks easily.

7. Dynamic Typing:
=  No need to declare variable types; Python decides it at runtime.


Q.2 History and evolution of Python.
 =======================================================================================
Ans.
 1. Origin:
 = Python was developed by Guido van Rossum in December 1989 at Centrum Wiskunde & Informatica (CWI), Netherlands.
 = Guido wanted a language that was simple, easy to read, and powerful.
 = The name "Python" was inspired by the British comedy series “Monty Python’s Flying Circus”, not the snake.

 2. Timeline of Python Evolution:
 = 1989 → Idea of Python was conceived by Guido van Rossum.
 = 1991 (Python 0.9.0) → First version released.
                         Included: exception handling, functions, core data types (str, list, dict).

 = 1994 (Python 1.0) → Official release.
                       Added tools like lambda, map, filter, and reduce.

 = 2000 (Python 2.0) → Major upgrade.
                       Introduced list comprehensions, garbage collection (using reference counting + cycle detecting).
                       First community-driven development.

 = 2008 (Python 3.0) → Significant change (not backward compatible with Python 2).
                       Improved Unicode support, cleaner syntax, new libraries.
                       Aim: remove redundancy and design flaws of Python 2

 = 2020 (Python 2 End of Life) → Official support for Python 2 was stopped.
                                 Python 3 became the only actively maintained version.

 = Present (Python 3.x series) → Continues to evolve with frequent updates.
                                 Latest versions improve performance, security, type hints, async programming, etc.

3. Current Status
= Python is one of the most widely used programming languages in the world.
= Popular in AI, Data Science, Web Development, Automation, IoT, Game Development.
= Maintained by the Python Software Foundation (PSF).

Q.3 Advantages of using Python over other programming languages
===========================================================================================================
Ans. Advantages of Using Python Over Other Programming Languages
1. Easy to Learn and Read
=  Python uses simple English-like syntax.
=  Easier for beginners compared to C, C++ or Java (less code, more clarity).

2. Fewer Lines of Code
=  Tasks that take dozens of lines in Java/C++ can be done in just a few lines in Python.
=  Example: Printing Hello World requires no class or boilerplate.

3. Interpreted Language
=  No separate compilation step (unlike C/C++).
=  Code is executed line by line, making debugging easier.

4. Cross-Platform Support
=  Python programs can run on Windows, Linux, macOS without modification.

5. Large Standard Library
=  Comes with built-in modules for math, file handling, networking, web services, etc.
=  Saves time compared to languages where developers must code these from scratch.

Q.4 Installing Python and setting up the development environment (Anaconda, PyCharm, or VS code)
==============================================================================================================
Ans.1. Installing Python (Basic Method)
    =  visit the official website: https://www.python.org
    =  Download the latest version of Python (3.x).
    =  Run the installer → Check “Add Python to PATH” option → Click Install.
    =  Verify installation:

            Open Command Prompt / Terminal.

                Type:
                    python --version
    =   It should show the installed Python version.

    2. Using Anaconda (for Data Science & ML)
    =  Anaconda is a distribution of Python with many scientific libraries (NumPy, Pandas, Matplotlib, Jupyter Notebook).
        Steps:
        1. Download Anaconda from https://www.anaconda.com
        2. Install it (choose Python 3.x version).
        3. Open Anaconda Navigator.
        4. Use Jupyter Notebook or Spyder IDE for coding.

    3. Using PyCharm (IDE for Python)
    =  PyCharm is a dedicated IDE for Python by JetBrains.
       Steps:
       1. Download PyCharm from https://www.jetbrains.com/pycharm
       2. Install and open PyCharm.
       3. Create a new project → Select Python interpreter (from installed Python or Anaconda).
       4. Start coding in a powerful environment with debugging and project management tools

    4. Using Visual Studio Code (VS Code)
    =  VS Code is a lightweight and popular code editor.
       Steps:
       1. Download VS Code from https://code.visualstudio.com
       2. Install Python Extension (from Extensions Marketplace).
       3. Select Python interpreter.
       4. Start coding and use built-in terminal for execution.

Q.5 Writing and executing your first Python program
==================================================================================================
Ans. program:
 
          print("Hello world")

    ---> execution of program:
         1. open terminal:
         =  cd path_to_your_file
         =  python hello.py
         2. output:
         =  Hello World

                  ***  Programming Style ***
Q.1 Understanding Python’s PEP 8 guidelines.
===================================================================================
Ans. 1. What is PEP 8?
     =  PEP = Python Enhancement Proposal.
     =  PEP 8 is the style guide for writing Python code.
     =  Created by Guido van Rossum, Barry Warsaw, and Nick Coghlan.
     =  Purpose: Make Python code clean, consistent, and readable for everyone.

     2. Key PEP 8 Guidelines
        1. Code Layout
        =  Use 4 spaces for indentation (not tabs).
        =  Keep lines ≤ 79 characters.
        =  Separate functions and classes with two blank lines.

        2. Naming Conventions
        =  Variables & functions → lowercase_with_underscores
        =  Constants → UPPERCASE_WITH_UNDERSCORES
        =  Classes → CamelCase
        =  Private variables → start with _

        3. Imports
        =  Imports should be at the top of the file.
        =  Order: Standard libraries → Third-party → Local modules.

        4. Spaces and Indentation
        =  Put one space after commas, around operators.
        =  No extra spaces inside brackets.

        5. Comments and Documentation
        =  Use # for single-line comments.
        =  Use docstrings (""" ... """) for functions, classes, and modules.

        6. Function and Class Definitions
        =  Keep functions short and clear.
        =  Each function should do one specific task.

    3. Why Follow PEP 8?
    =  Improves readability of code.
    =  Makes code consistent across projects.
    =  Easier for teams to collaborate.
    =  Encourages best practices in coding.
            
Q.2 Indentation, comments, and naming conventions in Python
=================================================================================================
Ans. 1. Indentation
     =  Indentation means leaving spaces at the beginning of a line.
     =  In Python, indentation is mandatory (unlike C, C++, Java where braces {} are used).
     =  Standard: 4 spaces per indentation level.

     2. Comments
     =  Comments are used to explain code (ignored by Python interpreter).
     =  Two types:
        1. Single-line comment → Start with #
        2. Multi-line comment / Docstring → Use triple quotes """ ... """

     3. Naming Conventions
     =  PEP 8 suggests the following naming rules:
        1. Variables & functions → lowercase_with_underscores
        2. Constants → UPPERCASE_WITH_UNDERSCORES
        3. Classes → CamelCase
        4. Private variables → Start with _ (underscore)
        5. Modules and packages → lowercase (short names preferred)

Q.3 Writing readable and maintainable code.
================================================================================================
Ans. Writing code isn’t just about making it work — it should also be easy to read, understand, and update in the future. Python encourages this through PEP 8 guidelines and best practices
        1. Use Proper Indentation
        =  Always use 4 spaces per indentation level.
        =  Makes the program structure clear.

        =  Example:
           for i in range(5):
               print("Hello", i)

        2. Follow Naming Conventions
        =  Variables & functions → lowercase_with_underscores
        =  Constants → UPPERCASE_WITH_UNDERSCORES
        =  Classes → CamelCase

        =  Example:
            MAX_LIMIT = 100
                def calculate_total(price, tax):
                    return price + tax
                class StudentRecord:
                    pass

        3. Use Comments Wisely
        =  Add comments to explain why you did something, not just what you did.
        =  Use docstrings (""" ... """) for functions, classes, and modules.

        =  Example:
           def factorial(n):
                """Return factorial of n using recursion."""
                if n == 0 or n == 1:
                    return 1
                return n * factorial(n - 1)

        3.  Keep Code Simple and Clean
        =   Break down large problems into small functions.
        =   Avoid deeply nested code.
        =   Don’t repeat code (use loops, functions, or modules instead).

        =  Example:
           def calculate_area(radius):
                return 3.14 * radius * radius
            def calculate_perimeter(radius):
                return 2 * 3.14 * radius

        4.  Organize Imports
        =   Place all imports at the top of the file.
        =   Order: Standard library → Third-party → Local modules.

        =   Example:
            import os
            import sys
            import numpy as np

        5.  Consistent Formatting
        =   Limit lines to 79 characters.
        =   Leave blank lines between functions and classes.
        =   Use spaces around operators.

        =   Example:
                x = 10 + 5
                    if x > 5:
                        print("Greater than 5")

Q.3 Writing readable and maintainable code.
=========================================================================================
Ans.Principles for Readable and Maintainable Code
    1. Proper Indentation
    =  Use 4 spaces per indentation level.
    =  Ensures clear program structure.

    2. Meaningful Naming
    =  Variables & functions → lowercase_with_underscores
    =  Constants → UPPERCASE_WITH_UNDERSCORES
    =  Classes → CamelCase

    3. Use Comments and Docstrings
    =  Single-line comment → #
    =  Multi-line / Documentation → """ ... """

    4. Keep Code Simple and Modular
    =  Break problems into small functions.
    =  Avoid repeating code (use functions, loops, or modules).

    5. Consistent Formatting
    =  Keep lines ≤ 79 characters.
    =  Add spaces around operators (x = a + b).
    =  Use blank lines between functions/classes.

                * * *  Core Python Concepts * * *
Q.1 Understanding data types: integers, floats, strings, lists, tuples, dictionaries, sets.
===================================================================================================
Ans. Data types
1. integers:
=  Whole numbers (positive, negative, or zero).
=   No decimal point. 

2. floats:
=  Numbers with decimal points or in exponential form.

3. strings:
=  Sequence of characters enclosed in single (') or double (") quotes.

4. lists:
=  Ordered, mutable (changeable) collection.
=  Can contain mixed data types.

5. tuples:
=  Ordered, immutable (cannot be changed) collection.

6. dictionaries:
=  Collection of key-value pairs.
=  Keys must be unique.

7. sets:
=  Unordered collection of unique elements (no duplicates).

Q.2 Python variables and memory allocation
=========================================================================================
Ans. 1. What is a Variable? 
     =  A variable is a name that refers to a value stored in memory.
     =  In Python, you don’t declare types — the interpreter decides based on the value assigned.

     2. Variable Assignment
     =  Python uses dynamic typing → type is decided at runtime.
     =   A variable can be reassigned to a different type.

     3. Memory Allocation in Python
     =  Python creates an object in memory.
     =  The variable name acts as a reference (pointer) to that object.
     =  Python does not create two separate objects for 10.
     =  Both a and b point to the same memory location (object reusability / interning).

     4. Garbage Collection
     =  If no variable refers to an object, it becomes unreachable.
     =  Python automatically frees this memory using Garbage Collector.

     5. Variable Scope
     =  Local Variable → defined inside a function.
     =  Global Variable → defined outside all functions.

Q.3 Python operators: arithmetic, comparison, logical, bitwise.
=================================================================================================
Ans. 1. arithmetic operators:

            | Operator | Meaning             | Example (a=10, b=3) | Result |
            | -------- | ------------------- | --------------------| ------ |
            | +        | Addition            | a + b               | 13     |
            | -        | Subtraction         | a - b               | 7      |
            | *        | Multiplication      | a * b               | 30     |
            | /        | Division (float)    | a / b               | 3.333… |
            | //       | Floor Division      | a // b              | 3      |
            | %        | Modulus (remainder) | a % b               | 1      |
            | **       | Exponent (power)    | a ** b              | 1000   |

    2.  comparison operators:

            |Operator| Meaning          | Example (a=10, b=3) | Result |
            | -------| ---------------- | ------------------- | ------ |
            | ==     | Equal to         | a == b              | False  |
            | !=     | Not equal to     | a != b              | True   |
            | >      | Greater than     | a > b               | True   |
            | <      | Less than        | a < b               | False  |
            | >=     | Greater or equal | a >= b              | True   |
            | <=     | Less or equal    | a <= b              | False  |

    3.  logical operators:

            |Operator| Meaning                   | Example (a=10, b=3) | Result |
            | ------ | ------------------------- | ------------------- | ------ |
            | and    | True if both are True     | a > 5 and b < 5     | True   |
            | or     | True if at least one True | a > 5 or b > 5      | True   |
            | not    | Reverses condition        | not(a > b)          | False  |

    4.  bitwise operators:

            | Operator | Meaning              | Example (a=10, b=3) | Result |    
            | -------- | -------------------- | --------------------| ------ |  
            | &        | AND                  | a & b               | 2      |     
            | \        | \                    | OR                  | `a     | 
            | ^        | XOR                  | a ^ b               | 9      |     
            | ~        | NOT (1’s complement) | ~a                  | -11    |     
            | <<       | Left shift           | a << 1              | 20     |     
            | >>       | Right shift          | a >> 1              | 5      |     


              * * *  Conditional Statements * * *
Q.1 Introduction to conditionalstatements: if, else, elif.
===========================================================================================
Ans.Introduction to Conditional Statements in Python
    = Conditional statements are used to make decisions in a program based on conditions (True/False).
    = They allow a program to execute different blocks of code depending on the situation.

1. The if Statement
=  Executes a block of code only if the condition is True.
=  Example:
            age = 18
            if age >= 18:
                    print("You are eligible to vote.")

2. The if–else Statement
= if → runs when condition is True.
= else → runs when condition is False.
= Example:
            age = 16
            if age >= 18:
                print("You can vote.")
            else:
                print("You are not eligible to vote yet.")

3. The if–elif–else Statement
= elif (short for else if) checks multiple conditions.
= Only the first True condition is executed.
= If none are True, the else block runs.
= Example:
            marks = 72
            if marks >= 90:
                print("Grade: A+")
            elif marks >= 75:
                print("Grade: A")
            elif marks >= 60:
                print("Grade: B")
            else:
                print("Grade: C")

Q.2 Nested if-else conditions.
================================================================================================
Ans. A nested if means an if statement inside another if or else block.
     It is used when decisions depend on multiple levels of conditions

=>  syntax:
            if condition1:
                if condition2:
                    # Code block if both condition1 and condition2 are True
                 else:
                    # Code block if condition1 is True but condition2 is False
            else:
                    # Code block if condition1 is False

=> Example:
            age = 20
            citizen = True
            if age >= 18:  # Outer if
                    if citizen:  # Inner if
                        print("You are eligible to vote.")
                    else:
                        print("You must be a citizen to vote.")
             else:
                    print("You are under 18, not eligible to vote.")


                           * * * Looping * * *
Q.1 Introduction to for and while loops. 
=================================================================================================
Ans. 
1. For loop
= The for loop is used to iterate (repeat) over a sequence like a list, tuple, string, or range.
= It executes a block of code for each element in the sequence.
= It is generally used when the number of iterations is known.

2. While loop
= The while loop is used to repeat a block of code as long as a condition is true.
= It is generally used when the number of iterations is not known in advance.
= If the condition never becomes False, the loop will run infinitely.

Q.2 How loops work in Python.
==============================================================================================
= Loops are used to execute a block of code repeatedly until a condition is met. Python mainly supports two types of loops: for loop and while loop.
1. for loop
= A for loop is used to iterate (go through) each element of a sequence (list, tuple, string, dictionary, range, etc.).
= The loop automatically picks the next item from the sequence and assigns it to a variable.
= It continues until there are no items left in the sequence.

2. while loop
= A while loop keeps running as long as a condition is True.
= Each time the loop body is executed, the condition is checked again.
= If the condition becomes False, the loop stops.

3. Loop Control Statements
Python provides special statements to control loop execution:
= break → Exits the loop immediately.
= continue → Skips the current iteration and moves to the next one.
= pass → Does nothing, just a placeholder.

Q.3 Using loops with collections (lists, tuples, etc.). 
===================================================================================================
Ans. Collections are data structures that store multiple items. The most common collections are list, tuple, set, dictionary, and string. Loops allow us to iterate through each element of these collections.

1. Loop with a list:
= A list is an ordered collection of items.

=> Example:
     l = ["python","java","RDBMS"]
     for i in l:
          print(i)

2. loop with a tuple:
= Tuples are similar to lists but immutable (cannot be changed).

=> Example:
     t = (10,20,30,40)
     for i in t:
          print(i)

3. loop with a set:
= A set is an unordered collection (no duplicates).

=> Example:
     s = {"red","orange","green"}
     for i in s:
         print(s)

4. loop with a dictionary
= Dictionaries store key-value pairs. You can loop through keys, values, or both.

=> Example
     d = {"name":"jhon","age":25}
     for i,j in d.items():
             print(i,j)

                   * * * Generators and Iterators * * *
Q.1 Understanding how generators work in Python. 
=================================================================================================
Ans.
1. What is a Generator?
= A generator is a special type of function that produces values one at a time instead of returning them all at once.
= Unlike normal functions that use return, generators use the yield keyword.
= Each time the generator is called, execution pauses at yield and resumes from there on the next call.

2. Why Use Generators?
= Generators are memory efficient because they don’t store all values in memory, they generate values when needed.
= Useful for working with large datasets, infinite sequences, or streams of data.

Q.2 Difference between yield and return. 
=================================================================================================
Ans.
| Feature              |  return                                                    | yield                                                                              |
| -------------------- | ---------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| **Purpose**          | Ends a function and **returns a single value**.            | Produces a value and **pauses the function**, allowing it to resume later.           |
| **Function Type**    | Used in **normal functions**.                              | Used in **generator functions**.                                                     |
| **Number of Values** | Function can return **only once**.                         | Function can yield **multiple times**.                                               |
| **Execution Flow**   | After `return`, function **terminates completely**.        | After `yield`, function **pauses** and resumes from the same point on the next call. |
| **Memory Usage**     | Returns the whole result at once, may use a lot of memory. | Generates values **one at a time**, very memory-efficient.                           |
| **Usage**            | Good for final results like `sum`, `max`, etc.             | Good for sequences, streams, or large datasets.                                      |

Q.3 Understanding iterators and creating custom iterators. 
=================================================================================================
Ans.An iterator is an object that allows you to iterate (loop) through a sequence of elements one by one.
   =  It implements two special methods:

   1.  __iter__() → returns the iterator object itself.

   2.  __next__() → returns the next item in the sequence.

   3.  When there are no more items, __next__() raises StopIteration

   4. Every collection (list, tuple, string, dict, set) in Python can be turned into an iterator using the iter() function.

                          * * * Function and methods * * *
Q.1 Defining and calling functions in Python. 
================================================================================================
Ans. 
= A function is a block of reusable code that performs a specific task.   
= Functions help in reducing code repetition and make programs more organized.
= In Python, you define a function using the def keyword.
= To call (use) a function, just write its name followed by parentheses (). If it requires parameters, pass them inside.

=> Example:
   def display():
       print("hello world")
   display()

Q.2 Function arguments (positional, keyword, default).
===============================================================================================
Ans. 
1. Positional Arguments
= Values are passed in the same order as the parameters in the function definition.
= The position matters.

2. Keyword Arguments
= You specify the parameter name when passing the value.
= Order does not matter because arguments are matched by name.

3. Default Arguments
= You can assign a default value to a parameter in the function definition.
= If the caller doesn’t provide a value, the default is used.

Q.3 Scope of variables in Python. 
===============================================================================================
Ans.
= Scope defines the region of a program where a variable is recognized.
= Variables can have local or global scope.

-----> Types of scoope
1.Local Scope
= A variable created inside a function belongs to the local scope.
= It is accessible only within that function.

2.Global Scope
= A variable created outside any function is global.
= It can be accessed from anywhere in the program.

Q.4 Built-in methods for strings, lists, etc.
==================================================================================================
Ans.
1.String Methods (str)
= Strings are immutable, but you can perform many operations:
----> string methods:

                s.lower() → " hello world " (converts to lowercase)

                s.upper() → " HELLO WORLD " (converts to uppercase)

                s.strip() → "Hello World" (removes spaces)

                s.replace("World", "Python") → " Hello Python "

                s.split() → ["Hello", "World"] (splits into list)

                s.join(['Hi', 'Python']) → "Hi Python" (joins with space/string)

                s.find("lo") → 3 (index of substring)

                s.startswith("He") → True

                s.endswith("ld") → True

                s.isalpha() → False (only alphabets?)

                s.isdigit() → False (only digits?)

2. List Methods (list)
= Lists are mutable → you can modify them
-----> list Method
                l.append(5) → [1,2,3,4,5]

                l.insert(2, 10) → [1,2,10,3,4,5]

                l.extend([6, 7]) → [1,2,10,3,4,5,6,7]

                l.remove(10) → [1,2,3,4,5,6,7]

                l.pop() → removes last element (or index)

                l.sort() → sorts ascending

                l.reverse() → reverses the list

                l.index(3) → 2 (first index of element)

                l.count(2) → 1 (occurrence count)

                l.clear() → []

3. Tuple Methods (tuple)
= Tuples are immutable, so only a few methods exist:
------> tuple Method
                count() ->	Returns the number of times a specified value occurs in a tuple
                index() ->  Searches the tuple for a specified value and returns the position of where it was found

4. Set Methods (set)
= Sets are unordered and unique.
------> set method
                    s.add(4) → {1,2,3,4}

                    s.update([5, 6]) → {1,2,3,4,5,6}

                    s.remove(2) → removes element (error if not found)

                    s.discard(10) → removes if present (no error)

                    s.pop() → removes random element

                    s.clear() → {}

                    s.union({7,8}) → {1,2,3,4,5,6,7,8}

                    s.intersection({2,3,9}) → {2,3}

                    s.difference({3,4}) → {1,2,5,6}

5. Dictionary Methods (dict)
= Dictionaries store key-value pairs.
------> dictionary method
                    d.keys() → ['a','b']

                    d.values() → [1,2]

                    d.items() → [('a',1), ('b',2)]

                    d.get("a") → 1

                    d.update({"c":3}) → {'a':1,'b':2,'c':3}

                    d.pop("b") → removes key "b"

                    d.popitem() → removes last inserted key-value pair

                    d.clear() → {}

                    d.setdefault("d", 10) → inserts if key not found

                      * * * Control Statements (Break, Continue, Pass) * * *
Q.1 Understanding the role of break, continue, and pass in Python loops.
==================================================================================================
Ans. 
1. break
= Terminates the loop immediately, regardless of the loop condition.
= Used when you want to exit a loop early.

=> Example:
          for i in range(5):
              if i==3:
                 break
            print(i)

2. continue
= Skips the current iteration and moves to the next iteration of the loop.
= Useful when you want to skip certain values. 

=> Example:
         for i in range(6):
             if i==2:
                continue
             print(i)

3. pass
= Does nothing; it’s a placeholder.
= Useful when syntax requires a statement but you don’t want to execute anything yet.

=> Example:
        if a>b:
           print("a is grater")
        else:
           pass

                      * * *  String Manipulation * * *
Q.1 Understanding how to access and manipulate strings.
===========================================================================================
Ans.
A string in Python is a sequence of characters enclosed in quotes (' ' or " "). Strings are immutable, which means you cannot change them in place, but you can create new strings by manipulating them.
1.Accessing Characters
= Use indexing to access individual characters. Index starts from 0.

2. Slicing Strings
= Extract a part of the string using slicing: s[start:end:step]

3. String Operations
= Concatenation (+) → join strings

4. String Formatting
= Using f-strings to embed Variables

Q.2 Basic operations: concatenation, repetition, string methods (upper(), lower(), etc.). 
===================================================================================================
Ans. 
1. concatenation
= it is used to join two strings
=> Example:
str = "hello"
str1 = "world"
str3 = str + str1
print(str3)

2. repetition
= Repeat a string multiple times using the * operator.
=> Example:
str = "hii"
print(str * 3)

3. string method
=  s.lower() → " hello world " (converts to lowercase)

   s.upper() → " HELLO WORLD " (converts to uppercase)

   s.strip() → "Hello World" (removes spaces)

   s.replace("World", "Python") → " Hello Python "

   s.split() → ["Hello", "World"] (splits into list)

   s.join(['Hi', 'Python']) → "Hi Python" (joins with space/string)

   s.find("lo") → 3 (index of substring)

   s.startswith("He") → True

   s.endswith("ld") → True

   s.isalpha() → False (only alphabets?)

   s.isdigit() → False (only digits?)

Q.3 String slicing. 
=============================================================================
Ans.String slicing allows you to extract a portion of a string using indices.

                    Syntax:
                    string[start : end : step]

start → starting index (inclusive)
end → ending index (exclusive)
step → how many steps to move forward (optional, default = 1)

1. Basic Slicing
= Ans
=> Example
        s = "Python"
        print(s[0:4])   
        print(s[2:])    
        print(s[:4])    
        print(s[:]) 

2. Using Negative Indices
= Negative indices count from the end of the string (-1 is last character).
=> Example
        s = "Python"
        print(s[-1])    
        print(s[-4:-1])
        print(s[-3:])  

            *  * * Advanced Python (map(), reduce(), filter(), Closures and Decorators) * * *
Q.1 How functional programming works in Python. 
================================================================================================
Ans. Functional programming (FP) is a programming paradigm where you write programs using functions and avoid changing state or mutable data. Python supports functional programming along with other paradigms.
1. Functions can be stored in variables, passed, or returned.
                def square(x):
                    return x*x

                f = square      
                print(f(5))   

2. Lambda functions
= Small one-line functions using lambda keyword.
= Useful in functional programming.

                square = lambda x: x*x
                print(square(6)) 

3. map()
= Applies a function to all items of an iterable.

                nums = [1, 2, 3, 4]
                squared = list(map(lambda x: x*x, nums))
                print(squared)   

4. filter()
= Filters elements based on a condition.

                nums = [1, 2, 3, 4, 5]
                even = list(filter(lambda x: x%2==0, nums))
                print(even)  

5. reduce()
= Applies a function cumulatively to reduce iterable to a single value.
= from functools import reduce

                nums = [1, 2, 3, 4]
                sum_all = reduce(lambda a, b: a+b, nums)
                print(sum_all)   

Q.2 Using map(), reduce(), and filter() functions for processing data.
=====================================================================================
Ans.
1. map()
= Purpose: Apply a function to every item in an iterable (like list, tuple).
= Returns a map object, usually converted to a list.

        Syntax:
        map(function, iterable)

=> Example:
        nums = [1, 2, 3, 4]
        squared = list(map(lambda x: x*x, nums))
        print(squared)

2. filter()
= Purpose: Select items from an iterable based on a condition.
= Returns a filter object, usually converted to a list.

        Syntax:
        filter(function, iterable)

=> Example:
        nums = [1, 2, 3, 4, 5]
        even = list(filter(lambda x: x % 2 == 0, nums))
        print(even)

3. reduce() (from functools module)
= Purpose: Apply a function cumulatively to reduce a sequence to a single value.
= Example: sum, product, or any cumulative operation.

        Syntax:
        from functools import reduce
        reduce(function, iterable)

=> Example:
        from functools import reduce

        nums = [1, 2, 3, 4]
        sum_all = reduce(lambda a, b: a + b, nums)
        product = reduce(lambda a, b: a * b, nums)

        print("Sum:", sum_all)
        print("Product:", product)

Q.3 Introduction to closures and decorators.
Ans.
1. Closure
= A closure is a function object that remembers values from its enclosing scope, even after that scope has finished execution.
= Essentially, a closure “encloses” the environment where it was created.

2. Decorators
= A decorator is a function that takes another function as input, adds functionality, and returns it.
= Decorators allow code reuse and modifying behavior without changing the original function.






















